# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:15:39+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, ConfigDict, Field, RootModel, confloat, conint, constr


class AccessPointAlreadyExists(RootModel[Any]):
    root: Any


class AccessPointArn(
    RootModel[
        constr(
            pattern=r'^arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}$',
            max_length=128,
        )
    ]
):
    root: constr(
        pattern=r'^arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}$',
        max_length=128,
    )


class AccessPointId(
    RootModel[
        constr(
            pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}|fsap-[0-9a-f]{8,40})$',
            max_length=128,
        )
    ]
):
    root: constr(
        pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:access-point/fsap-[0-9a-f]{8,40}|fsap-[0-9a-f]{8,40})$',
        max_length=128,
    )


class AccessPointLimitExceeded(RootModel[Any]):
    root: Any


class AccessPointNotFound(RootModel[Any]):
    root: Any


class AvailabilityZoneId(RootModel[str]):
    root: str


class AvailabilityZoneName(
    RootModel[constr(pattern=r'.+', min_length=1, max_length=64)]
):
    root: constr(pattern=r'.+', min_length=1, max_length=64)


class AvailabilityZonesMismatch(RootModel[Any]):
    root: Any


class AwsAccountId(
    RootModel[constr(pattern=r'^(\d{12})|(\d{4}-\d{4}-\d{4})$', max_length=14)]
):
    root: constr(pattern=r'^(\d{12})|(\d{4}-\d{4}-\d{4})$', max_length=14)


class Backup(RootModel[bool]):
    root: bool


class BadRequest(RootModel[Any]):
    root: Any


class BypassPolicyLockoutSafetyCheck(RootModel[bool]):
    root: bool


class ClientToken(RootModel[constr(pattern=r'.+', min_length=1, max_length=64)]):
    root: constr(pattern=r'.+', min_length=1, max_length=64)


class CreationToken(RootModel[constr(pattern=r'.+', min_length=1, max_length=64)]):
    root: constr(pattern=r'.+', min_length=1, max_length=64)


class DeleteAccessPointRequest(BaseModel):
    pass


class DeleteFileSystemPolicyRequest(BaseModel):
    pass


class DeleteFileSystemRequest(BaseModel):
    pass


class DeleteMountTargetRequest(BaseModel):
    pass


class DeleteReplicationConfigurationRequest(BaseModel):
    pass


class DependencyTimeout(RootModel[Any]):
    root: Any


class DescribeAccessPointsRequest(BaseModel):
    pass


class DescribeBackupPolicyRequest(BaseModel):
    pass


class DescribeFileSystemPolicyRequest(BaseModel):
    pass


class DescribeFileSystemsRequest(BaseModel):
    pass


class DescribeLifecycleConfigurationRequest(BaseModel):
    pass


class DescribeMountTargetSecurityGroupsRequest(BaseModel):
    pass


class DescribeMountTargetsRequest(BaseModel):
    pass


class DescribeReplicationConfigurationsRequest(BaseModel):
    pass


class DescribeTagsRequest(BaseModel):
    pass


class Encrypted(RootModel[bool]):
    root: bool


class FileSystemAlreadyExists(RootModel[Any]):
    root: Any


class FileSystemArn(RootModel[str]):
    root: str


class FileSystemId(
    RootModel[
        constr(
            pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$',
            max_length=128,
        )
    ]
):
    root: constr(
        pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$',
        max_length=128,
    )


class FileSystemInUse(RootModel[Any]):
    root: Any


class FileSystemLimitExceeded(RootModel[Any]):
    root: Any


class FileSystemNotFound(RootModel[Any]):
    root: Any


class FileSystemNullableSizeValue(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class FileSystemSizeValue(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class Gid(RootModel[conint(ge=0, le=4294967295)]):
    root: conint(ge=0, le=4294967295)


class IncorrectFileSystemLifeCycleState(RootModel[Any]):
    root: Any


class IncorrectMountTargetState(RootModel[Any]):
    root: Any


class InsufficientThroughputCapacity(RootModel[Any]):
    root: Any


class InternalServerError(RootModel[Any]):
    root: Any


class InvalidPolicyException(RootModel[Any]):
    root: Any


class IpAddress(
    RootModel[
        constr(
            pattern=r'^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$',
            min_length=7,
            max_length=15,
        )
    ]
):
    root: constr(
        pattern=r'^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$',
        min_length=7,
        max_length=15,
    )


class IpAddressInUse(RootModel[Any]):
    root: Any


class KmsKeyId(
    RootModel[
        constr(
            pattern=r'^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|mrk-[0-9a-f]{32}|alias/[a-zA-Z0-9/_-]+|(arn:aws[-a-z]*:kms:[a-z0-9-]+:\d{12}:((key/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})|(key/mrk-[0-9a-f]{32})|(alias/[a-zA-Z0-9/_-]+))))$',
            max_length=2048,
        )
    ]
):
    root: constr(
        pattern=r'^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|mrk-[0-9a-f]{32}|alias/[a-zA-Z0-9/_-]+|(arn:aws[-a-z]*:kms:[a-z0-9-]+:\d{12}:((key/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})|(key/mrk-[0-9a-f]{32})|(alias/[a-zA-Z0-9/_-]+))))$',
        max_length=2048,
    )


class LifeCycleState(Enum):
    creating = 'creating'
    available = 'available'
    updating = 'updating'
    deleting = 'deleting'
    deleted = 'deleted'
    error = 'error'


class ListTagsForResourceRequest(BaseModel):
    pass


class Marker(RootModel[constr(pattern=r'.+', min_length=1, max_length=128)]):
    root: constr(pattern=r'.+', min_length=1, max_length=128)


class MaxItems(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class MaxResults(RootModel[conint(ge=1)]):
    root: conint(ge=1) = Field(..., description='Max results used for pagination.')


class MountTargetConflict(RootModel[Any]):
    root: Any


class MountTargetCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class MountTargetId(
    RootModel[constr(pattern=r'^fsmt-[0-9a-f]{8,40}$', min_length=13, max_length=45)]
):
    root: constr(pattern=r'^fsmt-[0-9a-f]{8,40}$', min_length=13, max_length=45)


class MountTargetNotFound(RootModel[Any]):
    root: Any


class Name(RootModel[str]):
    root: str


class NetworkInterfaceId(RootModel[str]):
    root: str


class NetworkInterfaceLimitExceeded(RootModel[Any]):
    root: Any


class NoFreeAddressesInSubnet(RootModel[Any]):
    root: Any


class OwnerGid(RootModel[conint(ge=0, le=4294967295)]):
    root: conint(ge=0, le=4294967295)


class OwnerUid(RootModel[conint(ge=0, le=4294967295)]):
    root: conint(ge=0, le=4294967295)


class Path(
    RootModel[
        constr(
            pattern=r'^(\/|(\/(?!\.)+[^$#<>;`|&?{}^*/\n]+){1,4})$',
            min_length=1,
            max_length=100,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'^(\/|(\/(?!\.)+[^$#<>;`|&?{}^*/\n]+){1,4})$',
        min_length=1,
        max_length=100,
    )


class PerformanceMode(Enum):
    generalPurpose = 'generalPurpose'
    maxIO = 'maxIO'


class Permissions(
    RootModel[constr(pattern=r'^[0-7]{3,4}$', min_length=3, max_length=4)]
):
    root: constr(pattern=r'^[0-7]{3,4}$', min_length=3, max_length=4)


class Policy(RootModel[constr(pattern=r'[\s\S]+', min_length=1, max_length=20000)]):
    root: constr(pattern=r'[\s\S]+', min_length=1, max_length=20000)


class PolicyNotFound(RootModel[Any]):
    root: Any


class ProvisionedThroughputInMibps(RootModel[confloat(ge=1.0)]):
    root: confloat(ge=1.0)


class PutFileSystemPolicyRequest(BaseModel):
    BypassPolicyLockoutSafetyCheck_1: Optional[BypassPolicyLockoutSafetyCheck] = Field(
        None, alias='BypassPolicyLockoutSafetyCheck'
    )
    Policy_1: Policy = Field(..., alias='Policy')


class RegionName(
    RootModel[
        constr(
            pattern=r'^[a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-{0,1}[0-9]{0,1}$',
            min_length=1,
            max_length=64,
        )
    ]
):
    root: constr(
        pattern=r'^[a-z]{2}-((iso[a-z]{0,1}-)|(gov-)){0,1}[a-z]+-{0,1}[0-9]{0,1}$',
        min_length=1,
        max_length=64,
    )


class ReplicationNotFound(RootModel[Any]):
    root: Any


class ReplicationStatus(Enum):
    ENABLED = 'ENABLED'
    ENABLING = 'ENABLING'
    DELETING = 'DELETING'
    ERROR = 'ERROR'


class Resource(Enum):
    FILE_SYSTEM = 'FILE_SYSTEM'
    MOUNT_TARGET = 'MOUNT_TARGET'


class ResourceId(
    RootModel[
        constr(
            pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:(access-point/fsap|file-system/fs)-[0-9a-f]{8,40}|fs(ap)?-[0-9a-f]{8,40})$',
            max_length=128,
        )
    ]
):
    root: constr(
        pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:(access-point/fsap|file-system/fs)-[0-9a-f]{8,40}|fs(ap)?-[0-9a-f]{8,40})$',
        max_length=128,
    )


class ResourceIdType(Enum):
    LONG_ID = 'LONG_ID'
    SHORT_ID = 'SHORT_ID'


class Resources(RootModel[List[Resource]]):
    root: List[Resource] = Field(
        ..., description='EFS resources to which a preference applies to.'
    )


class SecondaryGids(RootModel[List[Gid]]):
    root: List[Gid] = Field(..., max_length=16, min_length=0)


class SecurityGroup(
    RootModel[constr(pattern=r'^sg-[0-9a-f]{8,40}', min_length=11, max_length=43)]
):
    root: constr(pattern=r'^sg-[0-9a-f]{8,40}', min_length=11, max_length=43)


class SecurityGroupLimitExceeded(RootModel[Any]):
    root: Any


class SecurityGroupNotFound(RootModel[Any]):
    root: Any


class SecurityGroups(RootModel[List[SecurityGroup]]):
    root: List[SecurityGroup] = Field(..., max_length=100)


class Status(Enum):
    ENABLED = 'ENABLED'
    ENABLING = 'ENABLING'
    DISABLED = 'DISABLED'
    DISABLING = 'DISABLING'


class SubnetId(
    RootModel[constr(pattern=r'^subnet-[0-9a-f]{8,40}$', min_length=15, max_length=47)]
):
    root: constr(pattern=r'^subnet-[0-9a-f]{8,40}$', min_length=15, max_length=47)


class SubnetNotFound(RootModel[Any]):
    root: Any


class TagKey(
    RootModel[
        constr(
            pattern=r'^(?![aA]{1}[wW]{1}[sS]{1}:)([\p{L}\p{Z}\p{N}_.:/=+\-@]+)$',
            min_length=1,
            max_length=128,
        )
    ]
):
    model_config = ConfigDict(
        regex_engine="python-re",
    )
    root: constr(
        pattern=r'^(?![aA]{1}[wW]{1}[sS]{1}:)([\p{L}\p{Z}\p{N}_.:/=+\-@]+)$',
        min_length=1,
        max_length=128,
    )


class TagKeys(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=50, min_length=1)


class TagValue(
    RootModel[constr(pattern=r'^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$', max_length=256)]
):
    root: constr(pattern=r'^([\p{L}\p{Z}\p{N}_.:/=+\-@]*)$', max_length=256)


class ThrottlingException(RootModel[Any]):
    root: Any


class ThroughputLimitExceeded(RootModel[Any]):
    root: Any


class ThroughputMode(Enum):
    bursting = 'bursting'
    provisioned = 'provisioned'
    elastic = 'elastic'


class Timestamp(RootModel[datetime]):
    root: datetime


class Token(RootModel[constr(pattern=r'.+', min_length=1, max_length=128)]):
    root: constr(pattern=r'.+', min_length=1, max_length=128) = Field(
        ..., description='Token used for pagination.'
    )


class TooManyRequests(RootModel[Any]):
    root: Any


class TransitionToIARules(Enum):
    AFTER_7_DAYS = 'AFTER_7_DAYS'
    AFTER_14_DAYS = 'AFTER_14_DAYS'
    AFTER_30_DAYS = 'AFTER_30_DAYS'
    AFTER_60_DAYS = 'AFTER_60_DAYS'
    AFTER_90_DAYS = 'AFTER_90_DAYS'
    AFTER_1_DAY = 'AFTER_1_DAY'


class TransitionToPrimaryStorageClassRules(Enum):
    AFTER_1_ACCESS = 'AFTER_1_ACCESS'


class Uid(RootModel[conint(ge=0, le=4294967295)]):
    root: conint(ge=0, le=4294967295)


class UnsupportedAvailabilityZone(RootModel[Any]):
    root: Any


class UntagResourceRequest(BaseModel):
    pass


class UpdateFileSystemRequest(BaseModel):
    ProvisionedThroughputInMibps_1: Optional[ProvisionedThroughputInMibps] = Field(
        None, alias='ProvisionedThroughputInMibps'
    )
    ThroughputMode_1: Optional[ThroughputMode] = Field(None, alias='ThroughputMode')


class ValidationException(RootModel[Any]):
    root: Any


class VpcId(RootModel[str]):
    root: str


class PosixUser1(BaseModel):
    Gid_1: Optional[Gid] = Field(None, alias='Gid')
    SecondaryGids_1: Optional[SecondaryGids] = Field(None, alias='SecondaryGids')
    Uid_1: Optional[Uid] = Field(None, alias='Uid')


class Field20150201AccountPreferencesGetRequest(BaseModel):
    MaxResults: Optional[conint(ge=1)] = Field(
        None, description='Max results used for pagination.'
    )
    NextToken: Optional[constr(pattern=r'.+', min_length=1, max_length=128)] = Field(
        None, description='Token used for pagination.'
    )


class Field20150201AccountPreferencesPutRequest(BaseModel):
    ResourceIdType_1: ResourceIdType = Field(
        ...,
        alias='ResourceIdType',
        description='A preference indicating a choice to use 63bit/32bit IDs for all applicable resources.',
    )


class Field20150201DeleteTagsFileSystemIdPostRequest(BaseModel):
    TagKeys: List[TagKey] = Field(
        ..., description='A list of tag keys to delete.', max_length=50, min_length=1
    )


class Field20150201FileSystemsFileSystemIdPutRequest(BaseModel):
    ProvisionedThroughputInMibps: Optional[confloat(ge=1.0)] = Field(
        None,
        description='(Optional) Sets the amount of provisioned throughput, in MiB/s, for the file system. Valid values are 1-1024. If you are changing the throughput mode to provisioned, you must also provide the amount of provisioned throughput. Required if <code>ThroughputMode</code> is changed to <code>provisioned</code> on update.',
    )
    ThroughputMode_1: Optional[ThroughputMode] = Field(
        None,
        alias='ThroughputMode',
        description="(Optional) Updates the file system's throughput mode. If you're not updating your throughput mode, you don't need to provide this value in your request. If you are changing the <code>ThroughputMode</code> to <code>provisioned</code>, you must also set a value for <code>ProvisionedThroughputInMibps</code>.",
    )


class BackupPolicy1(BaseModel):
    Status_1: Optional[Status] = Field(None, alias='Status')


class Field20150201FileSystemsFileSystemIdBackupPolicyPutRequest(BaseModel):
    BackupPolicy: BackupPolicy1 = Field(
        ...,
        description='The backup policy for the file system used to create automatic daily backups. If status has a value of <code>ENABLED</code>, the file system is being automatically backed up. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a>.',
    )


class Field20150201FileSystemsFileSystemIdPolicyPutRequest(BaseModel):
    BypassPolicyLockoutSafetyCheck: Optional[bool] = Field(
        None,
        description='(Optional) A boolean that specifies whether or not to bypass the <code>FileSystemPolicy</code> lockout safety check. The lockout safety check determines whether the policy in the request will lock out, or prevent, the IAM principal that is making the request from making future <code>PutFileSystemPolicy</code> requests on this file system. Set <code>BypassPolicyLockoutSafetyCheck</code> to <code>True</code> only when you intend to prevent the IAM principal that is making the request from making subsequent <code>PutFileSystemPolicy</code> requests on this file system. The default value is <code>False</code>. ',
    )
    Policy: constr(pattern=r'[\s\S]+', min_length=1, max_length=20000) = Field(
        ...,
        description='The <code>FileSystemPolicy</code> that you\'re creating. Accepts a JSON formatted policy definition. EFS file system policies have a 20,000 character limit. To find out more about the elements that make up a file system policy, see <a href="https://docs.aws.amazon.com/efs/latest/ug/access-control-overview.html#access-control-manage-access-intro-resource-policies">EFS Resource-based Policies</a>. ',
    )


class Field20150201MountTargetsPostRequest(BaseModel):
    FileSystemId: constr(
        pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$',
        max_length=128,
    ) = Field(
        ...,
        description='The ID of the file system for which to create the mount target.',
    )
    IpAddress: Optional[
        constr(
            pattern=r'^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$',
            min_length=7,
            max_length=15,
        )
    ] = Field(
        None,
        description='Valid IPv4 address within the address range of the specified subnet.',
    )
    SecurityGroups: Optional[List[SecurityGroup]] = Field(
        None,
        description='Up to five VPC security group IDs, of the form <code>sg-xxxxxxxx</code>. These must be for the same VPC as subnet specified.',
        max_length=100,
    )
    SubnetId: constr(
        pattern=r'^subnet-[0-9a-f]{8,40}$', min_length=15, max_length=47
    ) = Field(
        ...,
        description="The ID of the subnet to add the mount target in. For file systems that use One Zone storage classes, use the subnet that is associated with the file system's Availability Zone.",
    )


class Field20150201MountTargetsMountTargetIdSecurityGroupsPutRequest(BaseModel):
    SecurityGroups: Optional[List[SecurityGroup]] = Field(
        None,
        description='An array of up to five VPC security group IDs.',
        max_length=100,
    )


class BackupPolicy(BaseModel):
    Status_1: Status = Field(..., alias='Status')


class BackupPolicyDescription(BaseModel):
    BackupPolicy_1: Optional[BackupPolicy] = Field(None, alias='BackupPolicy')


class CreateMountTargetRequest(BaseModel):
    FileSystemId_1: FileSystemId = Field(..., alias='FileSystemId')
    IpAddress_1: Optional[IpAddress] = Field(None, alias='IpAddress')
    SecurityGroups_1: Optional[SecurityGroups] = Field(None, alias='SecurityGroups')
    SubnetId_1: SubnetId = Field(..., alias='SubnetId')


class CreationInfo(BaseModel):
    OwnerGid_1: OwnerGid = Field(..., alias='OwnerGid')
    OwnerUid_1: OwnerUid = Field(..., alias='OwnerUid')
    Permissions_1: Permissions = Field(..., alias='Permissions')


class DeleteTagsRequest(BaseModel):
    TagKeys_1: TagKeys = Field(..., alias='TagKeys')


class DescribeAccountPreferencesRequest(BaseModel):
    MaxResults_1: Optional[MaxResults] = Field(None, alias='MaxResults')
    NextToken: Optional[Token] = None


class DescribeMountTargetSecurityGroupsResponse(BaseModel):
    SecurityGroups_1: SecurityGroups = Field(..., alias='SecurityGroups')


class Destination(BaseModel):
    FileSystemId_1: FileSystemId = Field(..., alias='FileSystemId')
    LastReplicatedTimestamp: Optional[Timestamp] = None
    Region: RegionName
    Status: ReplicationStatus


class DestinationToCreate(BaseModel):
    AvailabilityZoneName_1: Optional[AvailabilityZoneName] = Field(
        None, alias='AvailabilityZoneName'
    )
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    Region: Optional[RegionName] = None


class Destinations(RootModel[List[Destination]]):
    root: List[Destination]


class DestinationsToCreate(RootModel[List[DestinationToCreate]]):
    root: List[DestinationToCreate]


class FileSystemPolicyDescription(BaseModel):
    FileSystemId_1: Optional[FileSystemId] = Field(None, alias='FileSystemId')
    Policy_1: Optional[Policy] = Field(None, alias='Policy')


class FileSystemSize(BaseModel):
    Timestamp_1: Optional[Timestamp] = Field(None, alias='Timestamp')
    Value: FileSystemSizeValue
    ValueInIA: Optional[FileSystemNullableSizeValue] = None
    ValueInStandard: Optional[FileSystemNullableSizeValue] = None


class LifecyclePolicy(BaseModel):
    TransitionToIA: Optional[TransitionToIARules] = None
    TransitionToPrimaryStorageClass: Optional[TransitionToPrimaryStorageClassRules] = (
        None
    )


class ModifyMountTargetSecurityGroupsRequest(BaseModel):
    SecurityGroups_1: Optional[SecurityGroups] = Field(None, alias='SecurityGroups')


class MountTargetDescription(BaseModel):
    AvailabilityZoneId_1: Optional[AvailabilityZoneId] = Field(
        None, alias='AvailabilityZoneId'
    )
    AvailabilityZoneName_1: Optional[AvailabilityZoneName] = Field(
        None, alias='AvailabilityZoneName'
    )
    FileSystemId_1: FileSystemId = Field(..., alias='FileSystemId')
    IpAddress_1: Optional[IpAddress] = Field(None, alias='IpAddress')
    LifeCycleState_1: LifeCycleState = Field(..., alias='LifeCycleState')
    MountTargetId_1: MountTargetId = Field(..., alias='MountTargetId')
    NetworkInterfaceId_1: Optional[NetworkInterfaceId] = Field(
        None, alias='NetworkInterfaceId'
    )
    OwnerId: Optional[AwsAccountId] = None
    SubnetId_1: SubnetId = Field(..., alias='SubnetId')
    VpcId_1: Optional[VpcId] = Field(None, alias='VpcId')


class MountTargetDescriptions(RootModel[List[MountTargetDescription]]):
    root: List[MountTargetDescription]


class PosixUser(BaseModel):
    Gid_1: Gid = Field(..., alias='Gid')
    SecondaryGids_1: Optional[SecondaryGids] = Field(None, alias='SecondaryGids')
    Uid_1: Uid = Field(..., alias='Uid')


class PutAccountPreferencesRequest(BaseModel):
    ResourceIdType_1: ResourceIdType = Field(..., alias='ResourceIdType')


class PutBackupPolicyRequest(BaseModel):
    BackupPolicy_1: BackupPolicy = Field(..., alias='BackupPolicy')


class ReplicationConfigurationDescription(BaseModel):
    CreationTime: Timestamp
    Destinations_1: Destinations = Field(..., alias='Destinations')
    OriginalSourceFileSystemArn: FileSystemArn
    SourceFileSystemArn: FileSystemArn
    SourceFileSystemId: FileSystemId
    SourceFileSystemRegion: RegionName


class ReplicationConfigurationDescriptions(
    RootModel[List[ReplicationConfigurationDescription]]
):
    root: List[ReplicationConfigurationDescription]


class ResourceIdPreference(BaseModel):
    ResourceIdType_1: Optional[ResourceIdType] = Field(None, alias='ResourceIdType')
    Resources_1: Optional[Resources] = Field(None, alias='Resources')


class RootDirectory(BaseModel):
    CreationInfo_1: Optional[CreationInfo] = Field(None, alias='CreationInfo')
    Path_1: Optional[Path] = Field(None, alias='Path')


class Tag(BaseModel):
    Key: TagKey
    Value: TagValue


class Tags(RootModel[List[Tag]]):
    root: List[Tag]


class Field20150201AccessPointsPostRequest(BaseModel):
    ClientToken: constr(pattern=r'.+', min_length=1, max_length=64) = Field(
        ...,
        description='A string of up to 64 ASCII characters that Amazon EFS uses to ensure idempotent creation.',
    )
    FileSystemId: constr(
        pattern=r'^(arn:aws[-a-z]*:elasticfilesystem:[0-9a-z-:]+:file-system/fs-[0-9a-f]{8,40}|fs-[0-9a-f]{8,40})$',
        max_length=128,
    ) = Field(
        ...,
        description='The ID of the EFS file system that the access point provides access to.',
    )
    PosixUser: Optional[PosixUser1] = Field(
        None,
        description='The full POSIX identity, including the user ID, group ID, and any secondary group IDs, on the access point that is used for all file system operations performed by NFS clients using the access point.',
    )
    RootDirectory_1: Optional[RootDirectory] = Field(
        None,
        alias='RootDirectory',
        description="Specifies the directory on the Amazon EFS file system that the access point provides access to. The access point exposes the specified file system path as the root directory of your file system to applications using the access point. NFS clients using the access point can only access data in the access point's <code>RootDirectory</code> and it's subdirectories.",
    )
    Tags: Optional[List[Tag]] = Field(
        None,
        description='Creates tags associated with the access point. Each tag is a key-value pair, each key must be unique. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.',
    )


class Field20150201CreateTagsFileSystemIdPostRequest(BaseModel):
    Tags: List[Tag] = Field(
        ...,
        description='An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value pair. ',
    )


class Field20150201FileSystemsPostRequest(BaseModel):
    AvailabilityZoneName: Optional[
        constr(pattern=r'.+', min_length=1, max_length=64)
    ] = Field(
        None,
        description='<p>Used to create a file system that uses One Zone storage classes. It specifies the Amazon Web Services Availability Zone in which to create the file system. Use the format <code>us-east-1a</code> to specify the Availability Zone. For more information about One Zone storage classes, see <a href="https://docs.aws.amazon.com/efs/latest/ug/storage-classes.html">Using EFS storage classes</a> in the <i>Amazon EFS User Guide</i>.</p> <note> <p>One Zone storage classes are not available in all Availability Zones in Amazon Web Services Regions where Amazon EFS is available.</p> </note>',
    )
    Backup: Optional[bool] = Field(
        None,
        description='<p>Specifies whether automatic backups are enabled on the file system that you are creating. Set the value to <code>true</code> to enable automatic backups. If you are creating a file system that uses One Zone storage classes, automatic backups are enabled by default. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/awsbackup.html#automatic-backups">Automatic backups</a> in the <i>Amazon EFS User Guide</i>.</p> <p>Default is <code>false</code>. However, if you specify an <code>AvailabilityZoneName</code>, the default is <code>true</code>.</p> <note> <p>Backup is not available in all Amazon Web Services Regions where Amazon EFS is available.</p> </note>',
    )
    CreationToken: constr(pattern=r'.+', min_length=1, max_length=64) = Field(
        ...,
        description='A string of up to 64 ASCII characters. Amazon EFS uses this to ensure idempotent creation.',
    )
    Encrypted: Optional[bool] = Field(
        None,
        description="A Boolean value that, if true, creates an encrypted file system. When creating an encrypted file system, you have the option of specifying an existing Key Management Service key (KMS key). If you don't specify a KMS key, then the default KMS key for Amazon EFS, <code>/aws/elasticfilesystem</code>, is used to protect the encrypted file system. ",
    )
    KmsKeyId: Optional[
        constr(
            pattern=r'^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|mrk-[0-9a-f]{32}|alias/[a-zA-Z0-9/_-]+|(arn:aws[-a-z]*:kms:[a-z0-9-]+:\d{12}:((key/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})|(key/mrk-[0-9a-f]{32})|(alias/[a-zA-Z0-9/_-]+))))$',
            max_length=2048,
        )
    ] = Field(
        None,
        description='<p>The ID of the KMS key that you want to use to protect the encrypted file system. This parameter is required only if you want to use a non-default KMS key. If this parameter is not specified, the default KMS key for Amazon EFS is used. You can specify a KMS key ID using the following formats:</p> <ul> <li> <p>Key ID - A unique identifier of the key, for example <code>1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li> <li> <p>ARN - An Amazon Resource Name (ARN) for the key, for example <code>arn:aws:kms:us-west-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab</code>.</p> </li> <li> <p>Key alias - A previously created display name for a key, for example <code>alias/projectKey1</code>.</p> </li> <li> <p>Key alias ARN - An ARN for a key alias, for example <code>arn:aws:kms:us-west-2:444455556666:alias/projectKey1</code>.</p> </li> </ul> <p>If you use <code>KmsKeyId</code>, you must set the <a>CreateFileSystemRequest$Encrypted</a> parameter to true.</p> <important> <p>EFS accepts only symmetric KMS keys. You cannot use asymmetric KMS keys with Amazon EFS file systems.</p> </important>',
    )
    PerformanceMode_1: Optional[PerformanceMode] = Field(
        None,
        alias='PerformanceMode',
        description="<p>The performance mode of the file system. We recommend <code>generalPurpose</code> performance mode for most file systems. File systems using the <code>maxIO</code> performance mode can scale to higher levels of aggregate throughput and operations per second with a tradeoff of slightly higher latencies for most file operations. The performance mode can't be changed after the file system has been created.</p> <note> <p>The <code>maxIO</code> mode is not supported on file systems using One Zone storage classes.</p> </note>",
    )
    ProvisionedThroughputInMibps: Optional[confloat(ge=1.0)] = Field(
        None,
        description='The throughput, measured in MiB/s, that you want to provision for a file system that you\'re creating. Valid values are 1-1024. Required if <code>ThroughputMode</code> is set to <code>provisioned</code>. The upper limit for throughput is 1024 MiB/s. To increase this limit, contact Amazon Web Services Support. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/limits.html#soft-limits">Amazon EFS quotas that you can increase</a> in the <i>Amazon EFS User Guide</i>.',
    )
    Tags: Optional[List[Tag]] = Field(
        None,
        description='Use to create one or more tags associated with the file system. Each tag is a user-defined key-value pair. Name your file system on creation by including a <code>"Key":"Name","Value":"{value}"</code> key-value pair. Each key must be unique. For more information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging Amazon Web Services resources</a> in the <i>Amazon Web Services General Reference Guide</i>.',
    )
    ThroughputMode_1: Optional[ThroughputMode] = Field(
        None,
        alias='ThroughputMode',
        description='<p>Specifies the throughput mode for the file system. The mode can be <code>bursting</code>, <code>provisioned</code>, or <code>elastic</code>. If you set <code>ThroughputMode</code> to <code>provisioned</code>, you must also set a value for <code>ProvisionedThroughputInMibps</code>. After you create the file system, you can decrease your file system\'s throughput in Provisioned Throughput mode or change between the throughput modes, with certain time restrictions. For more information, see <a href="https://docs.aws.amazon.com/efs/latest/ug/performance.html#provisioned-throughput">Specifying throughput with provisioned mode</a> in the <i>Amazon EFS User Guide</i>. </p> <p>Default is <code>bursting</code>.</p>',
    )


class Field20150201FileSystemsFileSystemIdLifecycleConfigurationPutRequest(BaseModel):
    LifecyclePolicies: List[LifecyclePolicy] = Field(
        ...,
        description="<p>An array of <code>LifecyclePolicy</code> objects that define the file system's <code>LifecycleConfiguration</code> object. A <code>LifecycleConfiguration</code> object informs EFS lifecycle management and EFS Intelligent-Tiering of the following:</p> <ul> <li> <p>When to move files in the file system from primary storage to the IA storage class.</p> </li> <li> <p>When to move files that are in IA storage to primary storage.</p> </li> </ul> <note> <p>When using the <code>put-lifecycle-configuration</code> CLI command or the <code>PutLifecycleConfiguration</code> API action, Amazon EFS requires that each <code>LifecyclePolicy</code> object have only a single transition. This means that in a request body, <code>LifecyclePolicies</code> must be structured as an array of <code>LifecyclePolicy</code> objects, one object for each transition, <code>TransitionToIA</code>, <code>TransitionToPrimaryStorageClass</code>. See the example requests in the following section for more information.</p> </note>",
        max_length=2,
    )


class Field20150201FileSystemsSourceFileSystemIdReplicationConfigurationPostRequest(
    BaseModel
):
    Destinations: List[DestinationToCreate] = Field(
        ...,
        description='An array of destination configuration objects. Only one destination configuration object is supported.',
    )


class Field20150201ResourceTagsResourceIdPostRequest(BaseModel):
    Tags: List[Tag] = Field(
        ...,
        description='An array of <code>Tag</code> objects to add. Each <code>Tag</code> object is a key-value pair.',
    )


class AccessPointDescription(BaseModel):
    AccessPointArn_1: Optional[AccessPointArn] = Field(None, alias='AccessPointArn')
    AccessPointId_1: Optional[AccessPointId] = Field(None, alias='AccessPointId')
    ClientToken_1: Optional[ClientToken] = Field(None, alias='ClientToken')
    FileSystemId_1: Optional[FileSystemId] = Field(None, alias='FileSystemId')
    LifeCycleState_1: Optional[LifeCycleState] = Field(None, alias='LifeCycleState')
    Name_1: Optional[Name] = Field(None, alias='Name')
    OwnerId: Optional[AwsAccountId] = None
    PosixUser_1: Optional[PosixUser] = Field(None, alias='PosixUser')
    RootDirectory_1: Optional[RootDirectory] = Field(None, alias='RootDirectory')
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class AccessPointDescriptions(RootModel[List[AccessPointDescription]]):
    root: List[AccessPointDescription]


class CreateAccessPointRequest(BaseModel):
    ClientToken_1: ClientToken = Field(..., alias='ClientToken')
    FileSystemId_1: FileSystemId = Field(..., alias='FileSystemId')
    PosixUser_1: Optional[PosixUser] = Field(None, alias='PosixUser')
    RootDirectory_1: Optional[RootDirectory] = Field(None, alias='RootDirectory')
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class CreateFileSystemRequest(BaseModel):
    AvailabilityZoneName_1: Optional[AvailabilityZoneName] = Field(
        None, alias='AvailabilityZoneName'
    )
    Backup_1: Optional[Backup] = Field(None, alias='Backup')
    CreationToken_1: CreationToken = Field(..., alias='CreationToken')
    Encrypted_1: Optional[Encrypted] = Field(None, alias='Encrypted')
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    PerformanceMode_1: Optional[PerformanceMode] = Field(None, alias='PerformanceMode')
    ProvisionedThroughputInMibps_1: Optional[ProvisionedThroughputInMibps] = Field(
        None, alias='ProvisionedThroughputInMibps'
    )
    Tags_1: Optional[Tags] = Field(None, alias='Tags')
    ThroughputMode_1: Optional[ThroughputMode] = Field(None, alias='ThroughputMode')


class CreateReplicationConfigurationRequest(BaseModel):
    Destinations: DestinationsToCreate


class CreateTagsRequest(BaseModel):
    Tags_1: Tags = Field(..., alias='Tags')


class DescribeAccessPointsResponse(BaseModel):
    AccessPoints: Optional[AccessPointDescriptions] = None
    NextToken: Optional[Token] = None


class DescribeAccountPreferencesResponse(BaseModel):
    NextToken: Optional[Token] = None
    ResourceIdPreference_1: Optional[ResourceIdPreference] = Field(
        None, alias='ResourceIdPreference'
    )


class DescribeMountTargetsResponse(BaseModel):
    Marker_1: Optional[Marker] = Field(None, alias='Marker')
    MountTargets: Optional[MountTargetDescriptions] = None
    NextMarker: Optional[Marker] = None


class DescribeReplicationConfigurationsResponse(BaseModel):
    NextToken: Optional[Token] = None
    Replications: Optional[ReplicationConfigurationDescriptions] = None


class DescribeTagsResponse(BaseModel):
    Marker_1: Optional[Marker] = Field(None, alias='Marker')
    NextMarker: Optional[Marker] = None
    Tags_1: Tags = Field(..., alias='Tags')


class FileSystemDescription(BaseModel):
    AvailabilityZoneId_1: Optional[AvailabilityZoneId] = Field(
        None, alias='AvailabilityZoneId'
    )
    AvailabilityZoneName_1: Optional[AvailabilityZoneName] = Field(
        None, alias='AvailabilityZoneName'
    )
    CreationTime: Timestamp
    CreationToken_1: CreationToken = Field(..., alias='CreationToken')
    Encrypted_1: Optional[Encrypted] = Field(None, alias='Encrypted')
    FileSystemArn_1: Optional[FileSystemArn] = Field(None, alias='FileSystemArn')
    FileSystemId_1: FileSystemId = Field(..., alias='FileSystemId')
    KmsKeyId_1: Optional[KmsKeyId] = Field(None, alias='KmsKeyId')
    LifeCycleState_1: LifeCycleState = Field(..., alias='LifeCycleState')
    Name: Optional[TagValue] = None
    NumberOfMountTargets: MountTargetCount
    OwnerId: AwsAccountId
    PerformanceMode_1: PerformanceMode = Field(..., alias='PerformanceMode')
    ProvisionedThroughputInMibps_1: Optional[ProvisionedThroughputInMibps] = Field(
        None, alias='ProvisionedThroughputInMibps'
    )
    SizeInBytes: FileSystemSize
    Tags_1: Tags = Field(..., alias='Tags')
    ThroughputMode_1: Optional[ThroughputMode] = Field(None, alias='ThroughputMode')


class FileSystemDescriptions(RootModel[List[FileSystemDescription]]):
    root: List[FileSystemDescription]


class LifecyclePolicies(RootModel[List[LifecyclePolicy]]):
    root: List[LifecyclePolicy] = Field(..., max_length=2)


class ListTagsForResourceResponse(BaseModel):
    NextToken: Optional[Token] = None
    Tags_1: Optional[Tags] = Field(None, alias='Tags')


class PutAccountPreferencesResponse(BaseModel):
    ResourceIdPreference_1: Optional[ResourceIdPreference] = Field(
        None, alias='ResourceIdPreference'
    )


class PutLifecycleConfigurationRequest(BaseModel):
    LifecyclePolicies_1: LifecyclePolicies = Field(..., alias='LifecyclePolicies')


class TagResourceRequest(BaseModel):
    Tags_1: Tags = Field(..., alias='Tags')


class DescribeFileSystemsResponse(BaseModel):
    FileSystems: Optional[FileSystemDescriptions] = None
    Marker_1: Optional[Marker] = Field(None, alias='Marker')
    NextMarker: Optional[Marker] = None


class LifecycleConfigurationDescription(BaseModel):
    LifecyclePolicies_1: Optional[LifecyclePolicies] = Field(
        None, alias='LifecyclePolicies'
    )
